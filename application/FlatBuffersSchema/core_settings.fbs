/**
  * All the core settings.
  */

include "common.fbs";

namespace FBS.Core;

table Settings {
   nick: string;
   peer_id: Common.Hash;

   language: Common.Language;

   chunk_size: uint32 = 67108864; // (64 MiB).
   buffer_size_reading: uint32 = 131072; // (128 KiB). Buffer used when reading files (uploading and computing hashes).
   buffer_size_writing: uint32 = 524288; // (512 KiB). Buffer used when writing files (downloading).
   socket_buffer_size: uint32 = 131072; // (128 KiB). Max size of the socket buffer, using when receiving or sending data over the sockets.
   socket_timeout: uint32 = 7000; // [ms].

   ///// FileManager /////
   minimum_duration_when_hashing: uint32 = 3000; // [ms].
   scan_period_unwatchable_dirs: uint32 = 30000; // [ms].
   unfinished_suffix_term: string; // Default: ".unfinished".
   minimum_free_space: uint32 = 1048576; // (1 MiB) After creating a file in a directory this is the minimum space it must be left.
   save_cache_period: uint32 = 60000; // [ms]. (1 min).
   check_received_data_integrity: bool = true; // All chunk data received will be checked against their hash if true.
   get_entries_timeout: uint32 = 5000; // [ms].

   ///// PeerManager /////
   pending_socket_timeout: uint32 = 10000; // [ms]. When a new connection is created we wait a maximum of this period before data incoming.
   peer_timeout_factor: double = 3.2; // If we don't receive any 'IMAlive' message from a peer during peer_timeout_factor * peer_imalive_period the peer is considering as dead.
   idle_socket_timeout: uint32 = 60000; // [ms], (1 min). Idle connections can exist for this duration.
   max_number_idle_socket: uint32 = 6; // The maximum number of idle socket per distant peer. (one for each TCP message : 'GetEntries',  'GetHashes', 'GetChunk').
   get_hashes_timeout: uint32 = 20000; // [ms] (20 s). After sending the message 'GetHashes' we will receive a stream of hashes, if the time between two hashes exceed this value, the request is aborted.

   ///// DownloadManager /////
   number_of_downloader: uint32 = 3; // Maximum number of simultaneous download.
   lan_speed: uint32 = 52428800; // [B/s]. (50 MiB/s).
   time_recheck_chunk_factor: double = 4; // If a chunk download take more than 4 times it should ('chunk_size' / 'lan_speed' is the minimum download time of a chunk) a better peer will be looking for.
   switch_to_another_peer_factor: double = 1.5; // To switch from the current peer to another the other download speed must be superior to this factor of the current speed.
   download_rate_valid_time_factor: uint32 = 3000; // A download rate for a peer is valid for a time period of 'download_rate_valid_time_factor' / 'lan_speed' [s].
   save_queue_period: uint32 = 60000; // [ms]. (1 min).
   block_duration_corrupted_data: uint32 = 30000; // [ms]. // When a received chunk do not match its hash, the sender is blocked for a while.

   ///// UploadManager /////
   upload_lifetime: uint32 = 5000; // [ms].
   upload_min_nb_thread: uint32 = 3; // To be efficiant, there is always this number of thread prepared to upload a chunk.
   upload_thread_lifetime: uint32 = 30000; // [ms].

   ///// NetworkListener /////
   peer_imalive_period: uint32 = 5000; // [ms]. Send an IMAlive message each 5 s.
   unicast_base_port: uint32 = 59487; // If it's already taken we will look further to a free port. (UDP + TCP).
   multicast_port: uint32 = 59486; // (UDP)
   multicast_group: uint32 = 3960285976; // IPv4: 236.13.43.24 / IPv6: ff0e:ec0d:2b18::
   channel: string; // Default: "main". Used with 'multicast_group' to define the IPv6 multicast group.
   multicast_ttl: uint32 = 31;
   max_udp_datagram_size: uint32 = 16356; // (~16 KiB). It doesn't include the IP+UDP header (28 bytes). It's an arbitrary limit and will not prevent IP fragmentation.

   // This is the max throughput allowed for the 'IMAlive' message for the whole network.
   // It means thats n * s / 'peer_imalive_period' must not exceed this value. Where n is the number of peer and s the size of the 'IMAlive' message.
   // The 'IMAlive' message size may vary from ~100 bytes to ~'max_udp_datagram_size' depending the number of hashes in it.
   max_imalive_throughput: uint32 = 1048576; // [B/s]. (1 MiB/s).

   udp_buffer_size: uint32 = 163840; // (10 * 16KiB).
   max_number_of_search_result_to_send: uint32 = 300;
   max_number_of_result_shown: uint32 = 5000; // For one search we accept a maximum of 5000 results.
   listen_address: string; // If address is empty then listen to any adresses, in this case the protocol is given by 'listenAny'.
   listen_any: Common.IPType = IPv6;

   ///// ChatSystem /////
   max_number_of_stored_chat_messages: uint32 = 500; // This is the number of saved message per room.
   number_of_chat_messages_to_retrieve: uint32 = 500; // Periodically we ask to a random peer the last messages.
   joined_chat_rooms : [string]; // The joined chat rooms, will be automatically joined at start.

   // [ms]. (2 seconds). Average time in second for everyone to know a new message: t = log2(n) * 'get_last_chat_messages_period' / 1000. Where n = number of peers.
   // Some examples for 'get_last_chat_messages_period' equals 2 seconds:
   //  - For n = 10 peers: t = 6.6 seconds.
   //  - For n = 100 peers: t = 13.3 seconds.
   //  - For n = 1000 peers: t = 19.9 seconds.
   get_last_chat_messages_period: uint32 = 2000;
   save_chat_messages_period: uint32 = 90000; // [ms]. (1.5 min).

   ///// RemoteControlManager /////
   remote_control_port: uint32 = 59485;
   remote_password: Common.Hash; // Hashed + salted. Only used for non-local connection. If defined salt field must be set.
   salt: uint64 = 42;
   remote_refresh_rate: uint32 = 1000; // [ms].
   remote_max_nb_connection: uint32 = 5;
   search_lifetime: uint32 = 5000; // [ms]. (5s)
   delay_gui_connection_fail: uint32 = 200; // When a GUI fails to connect to the core (for example by giving a wrong password) the answer is delayed [ms]. (0.2s)
   delay_before_sending_log_messages: uint32 = 250; // [ms]. When a new log message should be sent to the Core we wait this time for another log messages to try to send many at the same time.
}
