/**
  * Some common types.
  * All string are encoded in UTF-8.
  */

namespace DLAN.Common;

table Null {
}

table Error {
    message: string;
}

table Language {
    lang: string (required); // ISO-639 (two letters)
    country: string; // ISO-3166
}

// To identify a chunk, a shared dir or a user.
table Hash {
    hash: [byte]; // 20 bytes. If it doesn't exist the hash is null.
}

enum IPType : byte {
    IPv4 = 0,
    IPv6 = 1
}

table IP {
    type: IPType;
    ip: [byte]; // type == IPv4: 4 bytes. type == IPv6: 16 bytes. Big endian.
}

// A shared directory matches an existing handle, thus there is no need to have the complete path to it.
table SharedDir {
    id: Hash (required); // Identify a shared directory.
    // A name to identify the shared directory by human. It may correspond to the name of the shared directory itself. It may be used when creating the directories of a new downloading file.
    // This value is never used to build a path to a directory or a file.
    shared_name: string;
}

table EntryData {
    path: string (required); // Relative path from the sharing directory. For example : "/Videos/My cat/". A root directory or file has a one slash : "/". A shared directory has an empty path.
    name: string (required); // Directory name or file name. For example : "MyLOLCat.avi".
    size: uint64; // [bytes]. For the directory it's the sum of all sub-items.

    shared_dir: SharedDir; // The shared directory of the entry.
    exists: bool = true; // An entry may not yet be created.
}

table FileEntry {
    // mime_type: string; // The mime type of the file. TODO: uncomment when #243 is implemented.
    chunks: [Hash];
}

table DirEntry {
    data: EntryData (required);
    is_empty: bool = true; // Warning: a directory can be not empty and has a size of 0.
}

union Entry {
    FileEntry, DirEntry
}

table Entries {
    entries: [Entry];
}

enum FindPatternCategory : byte {
    FILE_DIR = 0,
    FILE = 1,
    DIR = 2
}

table FindPattern {
    pattern: string (required);
    min_size: uint64; // [B]. 0 means there is no minimum size.
    max_size: uint64; // [B]. 0 means there is no maximum size.
    extension_filter: [string]; // Only files that match one of the given extension will be returned.
    category: FindPatternCategory = FILE_DIR;
}

table EntryLevel {
    level: uint32;
    entry: Entry (required); // The entry must have the field 'shared_dir'.
}

// A result following a search.
// Entries may not be sorted in any particular way.
// See 'Core.Find' and 'GUI.Search' for more information.
table FindResult {
    tag: uint64;
    entry: [EntryLevel];
    peer_id: Hash;
}

// 'id' is randomly generated for each message.
table ChatMessage {
    id: uint64;
    message: string (required);
    peer_id: Hash;
    time: uint64;
    peer_nick: string;
    chat_room: string;
    peer_ids_answers: [Hash];
}

// All messages must belong to the same chat room (or from no room if they are from the main chat).
// The messages are always sorted from oldest to youngest.
table ChatMessages {
    messages: [ChatMessage];
}

enum Protocol : byte {
    IPv4 = 0,
    IPv6 = 1
}

table Address {
    address: string (required);
    protocol: Protocol;
    listened: bool;
}

table interface {
    id: uint32;
    name: string (required);
    addresses: [Address];
    isUp: bool;
}